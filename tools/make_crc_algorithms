#!/usr/bin/env bash

set -e

###############################################################################

function find_tmp_dir()
{
  local tmpdir

  for tmpdir in "$TMPDIR" "$TMP" /tmp /var/tmp "$PWD" ; do
    test -d "$tmpdir" && break
  done

  echo "$tmpdir"
}

###############################################################################

function check_exclusions()
{
  local file_name="$1"

  case "$file_name" in
    'crc12_umts.inc')  echo "exclude" ;;
    'crc8_fast4.inc')  echo "exclude" ;;
    'crc16_fast4.inc') echo "exclude" ;;
    'crc16_fast6.inc') echo "exclude" ;;
    'crc24_fast4.inc') echo "exclude" ;;
    'crc24_fast6.inc') echo "exclude" ;;
    'crc32_fast6.inc') echo "exclude" ;;
    'crc64_fast6.inc') echo "exclude" ;;
    *)                 echo "ok" ;;
  esac
}

###############################################################################

function reverse_bits()
{
  # 1. Reverse all the bits about a 64-bit pseudo-unsigned word
  #    NB. the shifts must be performed on a positive number to avoid sign extension

  local -i input=$(( 0x${1#*x} ))
  local -i result
  local -i result_lsb

  if (( input < 0 )) then
    result=$(( input & 0x7fffffffffffffff )) # make positive twos-complement
    result_lsb=$(( 1 )) # manually set after mask rotation
  else
    result=$(( input ))
    result_lsb=$(( 0 )) # automatically set by mask rotation
  fi

  local -i bit_swap_mask_0=$(( 0x5555555555555555 )) #  1-bit pairs, ie. individual bits
  local -i bit_swap_mask_1=$(( 0x3333333333333333 )) #  2-bit pairs
  local -i bit_swap_mask_2=$(( 0x0f0f0f0f0f0f0f0f )) #  4-bit pairs, ie. nibbles
  local -i bit_swap_mask_3=$(( 0x00ff00ff00ff00ff )) #  8-bit pairs, ie. bytes
  local -i bit_swap_mask_4=$(( 0x0000ffff0000ffff )) # 16-bit pairs

  result=$(( (bit_swap_mask_0 & (result >>  1)) | ((result & bit_swap_mask_0) <<  1) ))
  result=$(( (bit_swap_mask_1 & (result >>  2)) | ((result & bit_swap_mask_1) <<  2) ))
  result=$(( (bit_swap_mask_2 & (result >>  4)) | ((result & bit_swap_mask_2) <<  4) ))
  result=$(( (bit_swap_mask_3 & (result >>  8)) | ((result & bit_swap_mask_3) <<  8) ))
  result=$(( (bit_swap_mask_4 & (result >> 16)) | ((result & bit_swap_mask_4) << 16) ))
  result=$(( (result >> 32) | (result << 32) ))

  # 2. Return early for 64 bit reversals, being sure to set the result_lsb as needed

  local -i input_width_bits=$(( ${2:-64} ))

  if (( input_width_bits == 64 )) then
    result=$(( result | result_lsb ))
    printf "0x%016x" "$result"
    return 0
  fi

  # 3. Calculate result_msb, right-shift the result, apply result_msb and result_msb as needed

  local -i result_msb

  if (( result < 0 )) then
    result=$(( result & 0x7fffffffffffffff )) # make positive twos-complement
    result_msb=$(( 1 )) # manually set after right_shift
  else
    result_msb=$(( 0 )) # automatically set after right_shift
  fi

  result=$(( (result_msb << (input_width_bits - 1)) | (result >> (64 - input_width_bits)) | result_lsb ))

  local -i input_width_nibbles=$(( (input_width_bits + 3) / 4 ))

  printf "0x%0${input_width_nibbles}x" $(( result ))
  return 0
}

###############################################################################

function make_crc_algorithms()
{
  # 0. Parse and Validate args

  local catalog_root="$1"
  local crc_catalog="${catalog_root}/allcrcs.txt"

  if [[ ! -r "${crc_catalog}" ]] ; then
    echo "CRC Catalog is unreadable: \"${crc_catalog}\""
    exit 1
  fi

  local export_path="$2"
  mkdir -p "$export_path"

  if [[ ! -d "${export_path}" ]] ; then
    echo "Export Path is invalid: \"${export_path}\""
    exit 2
  fi

  # 1. Read the raw catalog,
  #    which contains one key-value parameterised algorithm per line

  local width
  local poly
  local init
  local refin
  local refout
  local xorout
  local check
  local residue
  local name
  local file_name

  local algorithm_inc

  while read -r width poly init refin refout xorout check residue name ; do
    width="${width##*=}"
    poly="${poly##*=}"
    init="${init##*=}"
    refin="${refin##*=}"
    refout="${refout##*=}"
    xorout="${xorout##*=}"
    check="${check##*=}"
    residue="${residue##*=}"

    name="${name//\"/}"
    name="${name##*=}"
    name="${name##*/}"
    name="${name//-/_}"

    # 2. Encode Polynomial Reflection in the 'F'orward / 'R'everse polynomial prefix,
    #    which is used to distinguish between table types in the generated C source

    local actual_init

    if [[ "${refin,,}" == "false" ]] ; then
      poly="${poly/0x/Fx}"
      actual_init=${init}
    else
      poly="${poly/0x/Rx}"
      actual_init=$(reverse_bits "$init" "$width")
    fi

    # 3. Coerce name into something friendly for file-systems

    file_name="crc${width}_${name,,}.inc"

    # 4. Generate the ".inc" source, which is expanded by C Preprocessor macros at build time

    printf "Generating Algorithm for \"${file_name}\"\n"

    local -i actual_init_value

    mapfile -d '' algorithm_inc << EOF
#if crc_algorithms_inc == INCLUDE_INTERFACE

#include "crc_algorithms/interface.h"

make_crc${width}_interface(
  /* .name     =  */    ${name},
  /* .poly     =  */    ${poly},
  /* .init     =  */    ${init},
  /* .refin    =  */    ${refin},
  /* .refout   =  */    ${refout},
  /* .xorout   =  */    ${xorout},
  /* .check    =  */    ${check},
  /* .residue  =  */    ${residue})

#elif crc_algorithms_inc == INCLUDE_IMPLEMENTATION

#include "crc_tables/standard/crc${width}_${poly}.h"

make_crc${width}_implementation(
  /* .name     =  */    ${name},
  /* .poly     =  */    ${poly},
  /* .init     =  */    ${actual_init},
  /* .xorout   =  */    ${xorout})

#endif
EOF

    if [[ $(check_exclusions "$file_name") == 'exclude' ]] ; then
      printf "  !!!  EXCLUDING \"${file_name}\" -- See \"check_exclusions\" in \"${SCRIPT_NAME}\"  !!!\n"
    else
      echo -n "${algorithm_inc}" > "${export_path}/${file_name}"
    fi

  done < "$crc_catalog"
}

###############################################################################

function main()
{
  local SCRIPT_PATH=$(realpath "${BASH_SOURCE[0]%/*}")
  local SCRIPT_NAME="${BASH_SOURCE[0]##*/}"
  local REPO_ROOT="$(git rev-parse --show-toplevel)"

  CALLERS_WD="$PWD"

  if [[ "${BASH_SOURCE[0]}" == "${0}" ]] then
    SCRIPT_TMPDIR="$(find_tmp_dir)/${SCRIPT_NAME}"
  else
    SCRIPT_TMPDIR="$(find_tmp_dir)/bash_pid_$$"
  fi

  trap "clean_up ;" EXIT

  # 1. Setup catalog_root and export_path

  local catalog_root="${1:-${REPO_ROOT}/db/algorithm/raw_catalog}"
  local export_path="${2:-${REPO_ROOT}/crc_algorithms/standard}"

  # 2. Convert allcrcs.txt catalog to Fast-CRC table based algorithms

  make_crc_algorithms "$catalog_root" "$export_path"
}

###############################################################################

function clean_up()
{
  rm -rf "$SCRIPT_TMPDIR"
  cd "$CALLERS_WD" &> /dev/null;
}

###############################################################################

main "$@"

