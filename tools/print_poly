#!/usr/bin/env bash

function _print_poly_help()
{
  local tool
  local tool_name

  if [[ "${BASH_SOURCE[0]}" == "${0}" ]] then
    tool=".${SCRIPT_PATH#${REPO_ROOT}}/${SCRIPT_NAME}"
    tool_name="$SCRIPT_NAME"
  else
    tool="print_poly"
    tool_name="$tool"
  fi

  cat << EOF

$tool_name prints CRC polynomials in various notations.

The main application is printing human readable notations from hex:

  Koopman Notation :   $tool_name <koopman_hex> {||kn|koopman}
  Explicit Notation :  $tool_name <explicit_hex> {en|explicit}
  Normal Notation  :   $tool_name <normal_hex> <poly_degree>

  eg. print CRC-16/CCITT using various polynomial notations:

${tool} 1021 16
${tool} 0x1021 16
${tool} 11021 explicit
${tool} 0x11021 en
${tool} 8810
${tool} 8810 kn
${tool} 8810 koopman
${tool} 0x8810
${tool} 0x8810 koopman

The seconday application is converting between hex notations:

${tool} e2n 11021
${tool} explicit_to_normal 0x11021
${tool} e2k 0x11021
${tool} explicit_to_koopman 11021

${tool} k2e 0x8810
${tool} koopman_to_explicit 0x8810
${tool} k2n 8810
${tool} koopman_to_normal 8810

${tool} n2e 0x1021 16
${tool} normal_to_explicit 1021 16
${tool} n2k 1021 16
${tool} normal_to_koopman 0x1021 16

EOF
}

function _generate_bc_crc_poly_lib()
{
  local bc_libcrc

  mapfile -d '' bc_libcrc << EOF

/* bc script */

define div(x, y) {
  orig_scale = scale
  result = x / y
  scale = 0
  result = result / 1
  scale = orig_scale
  return result
}

define msb(x) {
  orig_scale = scale
  orig_ibase = ibase
  ibase = 2
  result = l(x)/l(2)
  scale = 0
  result = result / 1
  ibase = orig_ibase
  scale = orig_scale
  return result
}

define mod(x, y) {
  orig_scale = scale
  scale = 0
  result = x % y
  scale = orig_scale
  return result
}

define normal_to_explicit(normal, degree) {
  return (2 ^ degree) + normal
}

define normal_to_koopman(normal, degree) {
  explicit = (2 ^ degree) + normal
  return div(explicit, 2)
}

define koopman_to_explicit(koopman) {
  return (koopman * 2) + 1
}

define koopman_to_normal(koopman) {
  degree = msb(koopman) + 1
  explicit = koopman_to_explicit(koopman)
  print div(explicit, 2) , degree
}

define explicit_to_koopman(explicit) {
  return div(explicit, 2)
}

define explicit_to_normal(explicit) {
  degree = msb(explicit)
  print div(explicit, 2) , degree
}



EOF

  return "$bc_libcrc"
}

###############################################################################

function _koopman_poly_notation_to_bin()
{
  local -i koopman_notation=$(( "0x${1#0x}" ))
  local -i explicit_notation=$(( (koopman_notation * 2) + 1 ))
  echo $(echo "obase=2; ibase=10; $(( explicit_notation ))" | bc)
}

function _explicit_poly_notation_to_bin()
{
  local -i explicit_notation=$(( "0x${1#0x}" ))
  echo $(echo "obase=2; ibase=10; $(( explicit_notation ))" | bc)
}

function _normal_poly_notation_to_bin()
{
  local -i normal_notation=$(( "0x${1#0x}" ))

  if (( $2 < 64 )) ; then
    local -i explicit_notation=$(( (1 << $2) + normal_notation ))
    echo $(echo "obase=2; ibase=10; $(( explicit_notation ))" | bc)
  else
    local -i explicit_notation_high=$(( (1 << ($2 - 32)) + (normal_notation >> 32) ))
    local -i explicit_notation_low=$(( normal_notation & 0xffffffff ))
    echo $(printf "obase=2; ibase=16; 0x%X%X" "$explicit_notation_high" "$explicit_notation_low")
  fi
}

###############################################################################

function _koopman_poly_notation_to_explicit_notation()
{
  local -i koopman_notation=$(( "0x${1#0x}" ))
  local -i explicit_notation=$(( (koopman_notation * 2) + 1 ))
  printf "0x%x" "$explicit_notation"
}

function _koopman_poly_notation_to_normal_notation()
{
  local explicit_notation=$(_koopman_poly_notation_to_explicit_notation "$1")
  echo $(_explicit_poly_notation_to_normal_notation "${explicit_notation}")
}

function _explicit_poly_notation_to_normal_notation()
{
  local poly_bin=$(_explicit_poly_notation_to_bin "$1")
  local -i poly_bits="${#poly_bin}"
  local explicit_stripped="${1#0x}"
  printf "0x%s %d" "${explicit_stripped:1}" $(( poly_bits - 1 ))
}

function _explicit_poly_notation_to_koopman_notation()
{
  local -i explicit_notation=$(( "0x${1#0x}" ))
  local -i koopman_notation=$(( explicit_notation >> 1 ))
  printf "0x%x" "$koopman_notation"
}

function _normal_poly_notation_to_explicit_notation()
{
  local -i normal_notation=$(( "0x${1#0x}" ))
  local -i explicit_notation=$(( (1 << $2) + normal_notation ))
  printf "0x%x" "$explicit_notation"
}

function _normal_poly_notation_to_koopman_notation()
{
  local -i normal_notation=$(( "0x${1#0x}" ))
  local -i koopman_notation=$(( (((1 << $2) + normal_notation) - 1) >> 1 ))
  printf "0x%x" "$koopman_notation"
}

###############################################################################

# NB. The print_poly function runs in a subshell.
#     This allows exit on error even when the script is sourced.

function print_poly()
(
  # 0. Quick arg check

  if (( $# < 1 )) ; then
    _print_poly_help
    exit 1
  fi

  case "$1" in
    'k2e' | 'koopman_to_explicit')
      echo $(_koopman_poly_notation_to_explicit_notation "$2")
      exit 0 ;;

    'k2n' | 'koopman_to_normal')
      echo $(_koopman_poly_notation_to_normal_notation "$2")
      exit 0 ;;

    'e2n' | 'explicit_to_normal')
      echo $(_explicit_poly_notation_to_normal_notation "$2")
      exit 0 ;;

    'e2k' | 'explicit_to_koopman')
      echo $(_explicit_poly_notation_to_koopman_notation "$2")
      exit 0 ;;

    'n2e' | 'normal_to_explicit')
      echo $(_normal_poly_notation_to_explicit_notation "$2" "$3")
      exit 0 ;;

    'n2k' | 'normal_to_koopman')
      echo $(_normal_poly_notation_to_koopman_notation "$2" "$3")
      exit 0 ;;

    'h' | '-h' | 'help' | '--help')
      _print_poly_help
      exit 0 ;;
  esac

  # 1. Convert poly_hex to poly_bin

  local second_arg="${2:-koopman}"

  local poly_bin

  case "$second_arg" in
    'kn' | 'koopman')
      poly_bin=$(_koopman_poly_notation_to_bin "$1") ;;
    'en' | 'explicit')
      poly_bin=$(_explicit_poly_notation_to_bin "$1") ;;
    *)
      poly_bin=$(_normal_poly_notation_to_bin "$1" "$2") ;;
  esac

  local -i poly_bits="${#poly_bin}"

  # 2. Walk the poly_bin string.  NB. First character is MSb

  for (( i = 0 ;  i < $poly_bits ; i++ )) ; do
    if (( "${poly_bin:${i}:1}" == 0 )) ; then
      continue;
    fi

    local -i degree=$((poly_bits - 1 - i))

    if (( degree != 0 )) ; then
      printf "x^${degree} + "
    else
      printf "1"
    fi

  done
)

###############################################################################

if [[ "${BASH_SOURCE[0]}" == "${0}" ]] then
  set -e
  cd "${0%/*}" ; SCRIPT_PATH="$PWD" ; cd - > /dev/null
  SCRIPT_NAME="${0##*/}"
  REPO_ROOT="$(git rev-parse --show-toplevel)"
  print_poly "$@"
  echo
fi
